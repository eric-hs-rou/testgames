<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Mini Voxel Sandbox – Mobile</title>
  <meta name="theme-color" content="#0b0f14" />
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <style>
    :root { --bg:#0b0f14; --panel:rgba(13,18,26,.7); --border:#1f2a37; --text:#e6f1ff; }
    html, body { margin:0; height:100%; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; overscroll-behavior: none; }
    canvas { display:block; touch-action:none; }
    #ui { position: fixed; top: 10px; left: 10px; z-index: 10; }
    .card { background: var(--panel); border:1px solid var(--border); padding:10px 12px; border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .title { font-weight:800; font-size:16px; margin-bottom:6px; }
    .help { font-size:12px; opacity:.85; line-height:1.5; }
    #hotbar { position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; display: flex; gap: 8px; z-index: 12; }
    .slot { width: 44px; height: 44px; border-radius: 10px; border: 1px solid var(--border); background: var(--panel); display:grid; place-items:center; box-shadow: 0 8px 20px rgba(0,0,0,.35); font-weight:700; }
    .slot.active { outline: 2px solid #7dd3fc; }
    #actions { position: fixed; right: 14px; bottom: 18px; display:flex; flex-direction:column; gap:10px; z-index:12; }
    .btn { border:none; padding:12px 14px; border-radius: 12px; font-weight:700; background:#1d2836; color:var(--text); }
    #moveZone { position: fixed; left: 0; bottom: 0; width: 50vw; height: 55vh; z-index: 11; touch-action:none; }
    #lookZone { position: fixed; right: 0; bottom: 0; width: 50vw; height: 100vh; z-index: 11; touch-action:none; }
    #joystick { position:absolute; width: 120px; height: 120px; border-radius: 60px; border:1px solid var(--border); background: rgba(255,255,255,.04); left: 16px; bottom: 16px; z-index: 12; }
    #stick { position:absolute; width: 56px; height:56px; border-radius: 28px; background: rgba(125,211,252,.3); border:1px solid rgba(125,211,252,.6); left: 16px; bottom: 16px; transform: translate(32px, 32px); }
  </style>
</head>
<body>
  <div id="ui">
    <div class="card">
      <div class="title">Voxel – Mobile</div>
      <div class="help">Left area: drag joystick to move • Right area: drag to look • Place/Remove buttons on the right • Up/Down for height</div>
    </div>
  </div>
  <div id="hotbar"></div>
  <div id="actions">
    <button id="placeBtn" class="btn">Place</button>
    <button id="removeBtn" class="btn">Remove</button>
    <button id="upBtn" class="btn">Up</button>
    <button id="downBtn" class="btn">Down</button>
  </div>
  <div id="moveZone"></div>
  <div id="lookZone"></div>
  <div id="joystick"><div id="stick"></div></div>

  <script type="module">
    // Register service worker
    if ('serviceWorker' in navigator) {
      addEventListener('load', () => navigator.serviceWorker.register('./service-worker.js').catch(console.error));
    }
  </script>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(8, 6, 8);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.65);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(6, 10, 3);
    scene.add(dir);

    const dirVec = new THREE.Vector3();
    const rightVec = new THREE.Vector3(1,0,0);
    const blocks = new Map();

    const materials = [
      new THREE.MeshStandardMaterial({ color: 0x6bbf59 }),
      new THREE.MeshStandardMaterial({ color: 0x8b5a2b }),
      new THREE.MeshStandardMaterial({ color: 0x888888 }),
      new THREE.MeshStandardMaterial({ color: 0xc8a26a }),
      new THREE.MeshStandardMaterial({ color: 0xb64646 }),
    ];
    let activeMat = 0;

    const hotbar = document.getElementById('hotbar');
    const slots = [];
    for (let i=0;i<5;i++){
      const el = document.createElement('div');
      el.className = 'slot'+(i===0?' active':'');
      el.textContent = (i+1);
      el.addEventListener('click', ()=> selectSlot(i));
      hotbar.appendChild(el); slots.push(el);
    }
    function selectSlot(i){ activeMat = i; slots.forEach((s,idx)=> s.classList.toggle('active', idx===i)); }

    const cubeGeo = new THREE.BoxGeometry(1,1,1);
    function key(x,y,z){ return `${x}|${y}|${z}`; }
    function addBlock(x,y,z, matIndex=activeMat){
      const k = key(x,y,z); if (blocks.has(k)) return;
      const mesh = new THREE.Mesh(cubeGeo, materials[matIndex]);
      mesh.position.set(x+0.5, y+0.5, z+0.5);
      scene.add(mesh); blocks.set(k, mesh);
    }
    function removeBlock(x,y,z){
      const k = key(x,y,z); const m = blocks.get(k); if(!m) return; scene.remove(m); m.geometry.dispose(); blocks.delete(k);
    }

    // Ground
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a3b2f });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2; ground.position.y = 0; scene.add(ground);

    // Some demo pillars
    for (let i=0;i<15;i++){
      const gx = Math.floor((Math.random()-0.5)*20);
      const gz = Math.floor((Math.random()-0.5)*20);
      const h = 1 + Math.floor(Math.random()*4);
      for (let y=0;y<h;y++) addBlock(gx, y, gz, 2);
    }

    // Raycaster
    const raycaster = new THREE.Raycaster();
    function getTargetBlock(addInstead){
      // Raycast from camera center
      raycaster.setFromCamera({x:0, y:0}, camera);
      const intersects = raycaster.intersectObjects([...blocks.values()], false);
      if (intersects.length){
        const hit = intersects[0];
        const p = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(addInstead? 0.5 : -0.5));
        return { x: Math.floor(p.x), y: Math.floor(p.y), z: Math.floor(p.z) };
      } else if (addInstead){
        const groundHits = raycaster.intersectObjects([ground]);
        if (groundHits.length){
          const gp = groundHits[0].point;
          return { x: Math.floor(gp.x), y: 0, z: Math.floor(gp.z) };
        }
      }
      return null;
    }

    // --- UI buttons
    const placeBtn = document.getElementById('placeBtn');
    const removeBtn = document.getElementById('removeBtn');
    const upBtn = document.getElementById('upBtn');
    const downBtn = document.getElementById('downBtn');

    placeBtn.addEventListener('click', ()=>{ const t = getTargetBlock(true); if (t) addBlock(t.x, t.y, t.z, activeMat); });
    removeBtn.addEventListener('click', ()=>{ const t = getTargetBlock(false); if (t) removeBlock(t.x, t.y, t.z); });
    upBtn.addEventListener('click', ()=>{ camera.position.y += 0.8; });
    downBtn.addEventListener('click', ()=>{ camera.position.y -= 0.8; });

    // --- Look (right zone): drag to rotate
    const lookZone = document.getElementById('lookZone');
    let lookTouchId = null, lastLX = 0, lastLY = 0;
    function onLookStart(e){
      e.preventDefault();
      const t = (e.changedTouches || [e])[0];
      if (lookTouchId === null){ lookTouchId = t.identifier ?? 'mouse'; lastLX = t.clientX; lastLY = t.clientY; }
    }
    function onLookMove(e){
      if (lookTouchId === null) return;
      const touches = e.changedTouches || [e];
      for (const t of touches){
        if ((t.identifier ?? 'mouse') === lookTouchId){
          const dx = t.clientX - lastLX, dy = t.clientY - lastLY; lastLX = t.clientX; lastLY = t.clientY;
          const sensitivity = 0.003;
          camera.rotation.y -= dx * sensitivity;
          camera.rotation.x -= dy * sensitivity;
          camera.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, camera.rotation.x));
        }
      }
    }
    function onLookEnd(e){
      const touches = e.changedTouches || [e];
      for (const t of touches){ if ((t.identifier ?? 'mouse') === lookTouchId) lookTouchId = null; }
    }
    lookZone.addEventListener('touchstart', onLookStart, {passive:false});
    lookZone.addEventListener('touchmove', onLookMove, {passive:false});
    lookZone.addEventListener('touchend', onLookEnd, {passive:false});
    lookZone.addEventListener('mousedown', onLookStart);
    window.addEventListener('mousemove', onLookMove);
    window.addEventListener('mouseup', onLookEnd);

    // --- Movement (left zone joystick)
    const moveZone = document.getElementById('moveZone');
    const joystick = document.getElementById('joystick');
    const stick = document.getElementById('stick');
    let moveTouchId = null, originX=0, originY=0, mvX=0, mvY=0;
    function setStick(dx, dy){
      const maxR = 44; // px from center
      const len = Math.hypot(dx, dy);
      const k = len > maxR ? maxR/len : 1;
      const x = dx * k, y = dy * k;
      stick.style.transform = `translate(${32 + x}px, ${32 + y}px)`;
      mvX = x/maxR; mvY = y/maxR; // normalized -1..1
    }
    function resetStick(){
      stick.style.transform = 'translate(32px, 32px)';
      mvX = 0; mvY = 0;
    }
    function onMoveStart(e){
      e.preventDefault();
      const t = (e.changedTouches || [e])[0];
      if (moveTouchId === null){
        moveTouchId = t.identifier ?? 'mouse';
        const rect = joystick.getBoundingClientRect();
        originX = rect.left + rect.width/2;
        originY = rect.top + rect.height/2;
        const dx = t.clientX - originX, dy = t.clientY - originY;
        setStick(dx, dy);
      }
    }
    function onMoveMove(e){
      if (moveTouchId === null) return;
      const touches = e.changedTouches || [e];
      for (const t of touches){
        if ((t.identifier ?? 'mouse') === moveTouchId){
          const dx = t.clientX - originX, dy = t.clientY - originY;
          setStick(dx, dy);
        }
      }
    }
    function onMoveEnd(e){
      const touches = e.changedTouches || [e];
      for (const t of touches){
        if ((t.identifier ?? 'mouse') === moveTouchId){
          moveTouchId = null; resetStick();
        }
      }
    }
    moveZone.addEventListener('touchstart', onMoveStart, {passive:false});
    moveZone.addEventListener('touchmove', onMoveMove, {passive:false});
    moveZone.addEventListener('touchend', onMoveEnd, {passive:false});
    moveZone.addEventListener('mousedown', onMoveStart);
    window.addEventListener('mousemove', onMoveMove);
    window.addEventListener('mouseup', onMoveEnd);

    // Prevent iOS rubber-band on drag
    document.addEventListener('gesturestart', e=>e.preventDefault());

    // Render loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last)/1000); last = now;

      // Move camera using joystick vector (mvX: -1..1 left-right, mvY: -1..1 up-down)
      const speed = 6 * dt;
      // forward/back from mvY (negative is up on screen, so invert)
      const forward = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
      const right = new THREE.Vector3(1,0,0).applyEuler(camera.rotation);
      camera.position.addScaledVector(forward, -mvY * speed);
      camera.position.addScaledVector(right,   mvX * speed);

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
