<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Voxel Sandbox</title>
  <meta name="theme-color" content="#0b0f14" />
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; color:#e6f1ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #ui { position: fixed; top: 10px; left: 10px; z-index: 10; }
    #ui .card { background: rgba(13,18,26,.7); border:1px solid #1f2a37; padding:10px 12px; border-radius:12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    #ui .title { font-weight:800; font-size:16px; margin-bottom:6px; }
    #ui .help { font-size:12px; opacity:.85; line-height:1.5; }
    #hotbar { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; display: flex; gap: 8px; z-index: 10; }
    .slot { width: 44px; height: 44px; border-radius: 10px; border: 1px solid #1f2a37; background: rgba(13,18,26,.7); display:grid; place-items:center; box-shadow: 0 8px 20px rgba(0,0,0,.35); font-weight:700; }
    .slot.active { outline: 2px solid #7dd3fc; }
    canvas { display:block; }
    #reticle { position: fixed; left:50%; top:50%; transform: translate(-50%, -50%); width: 14px; height:14px; border:2px solid rgba(255,255,255,.75); border-radius:50%; z-index:10; pointer-events:none; }
    #overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; color:#e6f1ff; background: radial-gradient(1200px 600px at 50% 50%, rgba(12,18,26,.6), rgba(12,18,26,.9)); z-index:20; }
    #overlay.hide { display:none; }
    .btn { border:none; padding:10px 14px; border-radius: 12px; font-weight:700; background:#1d2836; color:#e6f1ff; margin-top:10px; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="card">
      <div class="title">Mini Voxel Sandbox</div>
      <div class="help">
        Click to lock mouse • WASD move • SPACE up • CTRL down • Mouse to look<br/>
        Left-click: remove block • Right-click: place block • Keys 1–5 select block type
      </div>
    </div>
  </div>
  <div id="hotbar"></div>
  <div id="reticle"></div>
  <div id="overlay">
    <div class="card" style="text-align:center">
      <div class="title" style="font-size:24px">Click to Start</div>
      <div class="help">This is a tiny Minecraft‑like sandbox (PWA). Place/remove cubes.</div>
      <button id="startBtn" class="btn">Enter World</button>
    </div>
  </div>

  <script type="module">
    // Register service worker for PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js').catch(console.error);
      });
    }
  </script>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(8, 6, 8);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.65);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(6, 10, 3);
    scene.add(dir);

    const vel = new THREE.Vector3();
    const dirVec = new THREE.Vector3();
    const keys = new Set();
    let pointerLocked = false;

    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');

    function lockPointer(){
      renderer.domElement.requestPointerLock();
    }

    document.addEventListener('pointerlockchange', () => {
      pointerLocked = document.pointerLockElement === renderer.domElement;
      overlay.classList.toggle('hide', pointerLocked);
    });

    startBtn.addEventListener('click', lockPointer);
    renderer.domElement.addEventListener('click', () => { if (!pointerLocked) lockPointer(); });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    addEventListener('keydown', (e)=>{
      if (e.repeat) return; keys.add(e.code);
      if (e.code.startsWith('Digit')) {
        const n = parseInt(e.code.slice(-1), 10);
        if (n >= 1 && n <= 5) selectSlot(n-1);
      }
    });
    addEventListener('keyup',   (e)=>{ keys.delete(e.code); });

    addEventListener('mousemove', (e)=>{
      if (!pointerLocked) return;
      const sensitivity = 0.0025;
      camera.rotation.y -= e.movementX * sensitivity;
      camera.rotation.x -= e.movementY * sensitivity;
      camera.rotation.x = Math.max(-Math.PI/2 + 0.001, Math.min(Math.PI/2 - 0.001, camera.rotation.x));
    });

    const BLOCK = 1.0;
    const blocks = new Map();

    const materials = [
      new THREE.MeshStandardMaterial({ color: 0x6bbf59 }),
      new THREE.MeshStandardMaterial({ color: 0x8b5a2b }),
      new THREE.MeshStandardMaterial({ color: 0x888888 }),
      new THREE.MeshStandardMaterial({ color: 0xc8a26a }),
      new THREE.MeshStandardMaterial({ color: 0xb64646 }),
    ];
    let activeMat = 0;

    const hotbar = document.getElementById('hotbar');
    const slots = [];
    for (let i=0;i<5;i++){
      const el = document.createElement('div');
      el.className = 'slot'+(i===0?' active':'');
      el.textContent = (i+1);
      hotbar.appendChild(el); slots.push(el);
    }
    function selectSlot(i){ activeMat = i; slots.forEach((s,idx)=> s.classList.toggle('active', idx===i)); }

    const cubeGeo = new THREE.BoxGeometry(BLOCK, BLOCK, BLOCK);

    function key(x,y,z){ return `${x}|${y}|${z}`; }
    function addBlock(x,y,z, matIndex=activeMat){
      const k = key(x,y,z); if (blocks.has(k)) return;
      const mesh = new THREE.Mesh(cubeGeo, materials[matIndex]);
      mesh.position.set(x+0.5, y+0.5, z+0.5);
      mesh.castShadow = true; mesh.receiveShadow = true;
      scene.add(mesh); blocks.set(k, mesh);
    }
    function removeBlock(x,y,z){
      const k = key(x,y,z); const m = blocks.get(k); if(!m) return; scene.remove(m); m.geometry.dispose(); blocks.delete(k);
    }

    {
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x2a3b2f });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI/2; ground.position.y = 0;
      ground.receiveShadow = true; scene.add(ground);
    }

    for (let i=0;i<15;i++){
      const gx = Math.floor((Math.random()-0.5)*20);
      const gz = Math.floor((Math.random()-0.5)*20);
      const h = 1 + Math.floor(Math.random()*4);
      for (let y=0;y<h;y++) addBlock(gx, y, gz, 2);
    }

    const raycaster = new THREE.Raycaster();
    function getTargetBlock(addInstead){
      raycaster.setFromCamera({x:0, y:0}, camera);
      const intersects = raycaster.intersectObjects([...blocks.values()], false);
      if (intersects.length){
        const hit = intersects[0];
        const p = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(addInstead? 0.5 : -0.5));
        const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
        return { x: bx, y: by, z: bz };
      } else {
        const groundHits = raycaster.intersectObjects(scene.children.filter(o=>o.geometry instanceof THREE.PlaneGeometry));
        if (groundHits.length && addInstead){
          const gp = groundHits[0].point;
          return { x: Math.floor(gp.x), y: 0, z: Math.floor(gp.z) };
        }
      }
      return null;
    }

    addEventListener('mousedown', (e)=>{
      if (!pointerLocked) return;
      if (e.button === 0){
        const t = getTargetBlock(false); if (t) removeBlock(t.x, t.y, t.z);
      } else if (e.button === 2){
        const t = getTargetBlock(true); if (t) addBlock(t.x, t.y, t.z, activeMat);
      }
    });
    addEventListener('contextmenu', (e)=>{ e.preventDefault(); });

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last)/1000); last = now;

      if (pointerLocked){
        const speedBase = 5;
        const fast = keys.has('ShiftLeft') ? 2.0 : 1.0;
        const speed = speedBase * fast * dt * 3.0;
        dirVec.set(0,0,-1).applyEuler(camera.rotation);
        const right = new THREE.Vector3(1,0,0).applyEuler(camera.rotation);

        if (keys.has('KeyW')) camera.position.addScaledVector(dirVec, speed);
        if (keys.has('KeyS')) camera.position.addScaledVector(dirVec, -speed);
        if (keys.has('KeyA')) camera.position.addScaledVector(right, -speed);
        if (keys.has('KeyD')) camera.position.addScaledVector(right, speed);
        if (keys.has('Space')) camera.position.y += speed;
        if (keys.has('ControlLeft')) camera.position.y -= speed;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
