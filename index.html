<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Two-Player Hex – Mobile Touch (R2 Board)</title>
  <style>
    :root{ --bg:#0b0f14; --panel:#121a24; --edge:#1f2a37; --text:#e6f1ff; --accent:#7dd3fc; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overscroll-behavior:none}
    .app{display:flex;flex-direction:column;min-height:100svh;padding-bottom:env(safe-area-inset-bottom)}
    .hud{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 12px;flex-wrap:wrap}
    .card{background:var(--panel);border:1px solid var(--edge);padding:8px 10px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .left{display:flex;gap:8px;align-items:center}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:8px 10px;border-radius:12px}
    .dot{width:16px;height:16px;border-radius:50%}
    .btn{border:none;background:#1d2836;color:var(--text);padding:12px 14px;border-radius:12px;font-weight:700}
    .stats{font-size:14px}
    canvas{display:block;width:100%;height:auto;aspect-ratio:9/14;border-top:1px solid var(--edge);border-bottom:1px solid var(--edge);background:linear-gradient(180deg,#0f1622,#0a0f17)}
    @media (min-width:720px){ canvas{aspect-ratio:16/9} }
    .legend{display:flex;gap:10px;align-items:center;padding:8px 12px}
    .sw{width:16px;height:16px;border-radius:4px;border:1px solid rgba(0,0,0,.25)}
  </style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <div class="left">
        <div id="turn" class="card badge"><div id="turnDot" class="dot" style="background:#0a0a0a"></div><span>Player 1 (Black)</span></div>
        <div class="card stats">Edges — Black: <b id="bEdges">0</b> • White: <b id="wEdges">0</b> • Grey: <b id="gEdges">0</b></div>
      </div>
      <div class="right">
        <button id="reset" class="btn">Reset</button>
      </div>
    </div>
    <canvas id="board"></canvas>
    <div class="legend">
      <div class="sw" style="background:#fecaca;border-color:#f87171"></div><span>Red</span>
      <div class="sw" style="background:#bbf7d0;border-color:#34d399"></div><span>Green</span>
      <div class="sw" style="background:#bfdbfe;border-color:#60a5fa"></div><span>Blue</span>
      <div class="sw" style="background:#fef9c3;border-color:#facc15"></div><span>Yellow</span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    // DPR-aware sizing
    function fitCanvas(){
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const rectW = canvas.clientWidth;
      const rectH = Math.max(420, canvas.clientHeight || (window.innerHeight * 0.7));
      canvas.width = Math.floor(rectW * dpr);
      canvas.height = Math.floor(rectH * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    }

    // Players & colors
    const P = { NONE:0, BLACK:1, WHITE:2 };
    const PLAYER_COLOR = { [P.BLACK]:'#0a0a0a', [P.WHITE]:'#f3f4f6' };
    const EDGE_GREY = '#9ca3af';

    // Pastel fills + darker outlines
    const COLOR_SET = [
      { fill:'#fecaca', stroke:'#f87171' }, // red
      { fill:'#bbf7d0', stroke:'#34d399' }, // green
      { fill:'#bfdbfe', stroke:'#60a5fa' }, // blue
      { fill:'#fef9c3', stroke:'#facc15' }, // yellow
    ];

    // Axial ring radius
    const BOARD_R = 2; // center + two rings

    // Data containers
    let R = 40; // hex radius (computed per layout)
    let center = {x:0,y:0};
    let hexes = [];
    let vertices = [];
    let edges = [];
    let hexVerts = [];

    // Helpers
    function hexPoints(cx, cy){
      const pts = [];
      for(let i=0;i<6;i++){
        const a = Math.PI/6 + i * Math.PI/3; // 30° + 60°i (pointy)
        pts.push({x: cx + R*Math.cos(a), y: cy + R*Math.sin(a)});
      }
      return pts;
    }
    function axialToPixel(q,r){
      const x = center.x + R * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
      const y = center.y + R * (3/2 * r);
      return {x,y};
    }
    function hexDistance(q,r){ const s = -q-r; return Math.max(Math.abs(q), Math.abs(r), Math.abs(s)); }

    // Vertex/edge registries with merge tolerance
    const VERT_EPS = 0.5; // px merge tolerance
    const vKey = (x,y)=> `${Math.round(x/ VERT_EPS)*VERT_EPS}|${Math.round(y/ VERT_EPS)*VERT_EPS}`;
    function edgeKey(a,b){ return a<b ? `${a}|${b}` : `${b}|${a}`; }

    function buildBoard(){
      // compute R so whole radius-2 board fits vertically on phone
      const pad = 16; // css px
      center = { x: canvas.clientWidth/2, y: canvas.clientHeight/2 };

      // First compute unit layout spans (R=1)
      const tmpCenters = [];
      for (let q=-BOARD_R;q<=BOARD_R;q++){
        for (let r=-BOARD_R;r<=BOARD_R;r++){
          if (hexDistance(q,r) <= BOARD_R){
            const x = (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
            const y = (3/2 * r);
            tmpCenters.push({x,y});
          }
        }
      }
      let minX=1e9,maxX=-1e9,minY=1e9,maxY=-1e9;
      const unitR = 1;
      const tipX = unitR; const tipY = unitR; // we will add polygon tips later
      for (const c of tmpCenters){
        minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x);
        minY = Math.min(minY, c.y); maxY = Math.max(maxY, c.y);
      }
      // include polygon extents: pointy top extends by R in x and y (approx)
      const spanX = (maxX - minX) + 2*unitR;
      const spanY = (maxY - minY) + 2*unitR;
      const availX = Math.max(200, canvas.clientWidth - 2*pad);
      const availY = Math.max(300, canvas.clientHeight - 2*pad);
      const scale = 0.95 * Math.min(availX/spanX/Math.sqrt(3), availY/spanY/1.5);
      R = Math.max(22, scale); // clamp minimum for touchability

      // rebuild structures
      hexes = []; vertices = []; edges = []; hexVerts = [];
      const vmap = new Map();
      const emap = new Map();

      function addVertex(x,y){
        const k = vKey(x,y);
        if (vmap.has(k)) return vmap.get(k);
        const id = vertices.length; vmap.set(k, id);
        vertices.push({ x, y, owner:P.NONE, edges:[] });
        return id;
      }
      function addEdge(a,b){
        const k = edgeKey(a,b);
        if (emap.has(k)) return emap.get(k);
        const id = edges.length; emap.set(k, id);
        edges.push({ a, b, color:0 });
        vertices[a].edges.push(id); vertices[b].edges.push(id);
        return id;
      }

      for (let q=-BOARD_R;q<=BOARD_R;q++){
        for (let r=-BOARD_R;r<=BOARD_R;r++){
          if (hexDistance(q,r) <= BOARD_R){
            const {x,y} = axialToPixel(q,r);
            const poly = hexPoints(x,y);
            const col = COLOR_SET[Math.floor(Math.random()*COLOR_SET.length)];
            const vids = poly.map(p => addVertex(p.x,p.y));
            for (let i=0;i<6;i++) addEdge(vids[i], vids[(i+1)%6]);
            hexes.push({ q,r, poly:vids, col });
            hexVerts.push(vids);
          }
        }
      }
    }

    // --- Game state & HUD
    let turn = P.BLACK; // black starts
    const $turn = document.getElementById('turn');
    const $turnDot = document.getElementById('turnDot');
    const $reset = document.getElementById('reset');
    const $bE = document.getElementById('bEdges');
    const $wE = document.getElementById('wEdges');
    const $gE = document.getElementById('gEdges');

    function updateHUD(){
      $turn.querySelector('span').textContent = turn===P.BLACK? 'Player 1 (Black)' : 'Player 2 (White)';
      $turnDot.style.background = turn===P.BLACK? PLAYER_COLOR[P.BLACK] : PLAYER_COLOR[P.WHITE];
      let b=0,w=0,g=0; for(const e of edges){ if(e.color===1) b++; else if(e.color===2) w++; else if(e.color===3) g++; }
      $bE.textContent = b; $wE.textContent = w; $gE.textContent = g;
    }
    function nextTurn(){ turn = (turn===P.BLACK? P.WHITE : P.BLACK); updateHUD(); draw(); }
    function reset(){ for (const v of vertices) v.owner = P.NONE; for (const e of edges) e.color = 0; turn = P.BLACK; updateHUD(); draw(); }
    $reset.addEventListener('click', reset, {passive:true});

    // Edge color from owners
    function edgeColorFromOwners(aOwner, bOwner){
      if (aOwner===P.NONE && bOwner===P.NONE) return 0;
      if (aOwner!==P.NONE && bOwner!==P.NONE && aOwner!==bOwner) return 3; // grey
      const c = (aOwner!==P.NONE? aOwner : bOwner);
      return c===P.BLACK? 1 : 2; // black or white
    }

    // Input helpers (touch-first)
    function getXY(e){
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width, scaleY = canvas.height / rect.height;
      if (e.touches && e.touches[0]){
        return { x:(e.touches[0].clientX-rect.left)*scaleX, y:(e.touches[0].clientY-rect.top)*scaleY };
      } else {
        return { x:(e.clientX-rect.left)*scaleX, y:(e.clientY-rect.top)*scaleY };
      }
    }

    function nearestVertex(px,py){
      let best=-1, bd=1e9; const TH = Math.max(16, 0.45*R); // scale with hex size
      for(let i=0;i<vertices.length;i++){
        const v=vertices[i]; const d = Math.hypot(px-v.x, py-v.y);
        if (d<bd){ bd=d; best=i; }
      }
      return bd<=TH? best : -1;
    }

    function placeAt(px,py){
      const vid = nearestVertex(px,py); if (vid<0) return;
      const v = vertices[vid]; if (v.owner!==P.NONE) return; // already taken
      v.owner = turn;
      for (const eid of v.edges){
        const e = edges[eid]; const other = (e.a===vid? e.b : e.a);
        e.color = edgeColorFromOwners(vertices[vid].owner, vertices[other].owner);
      }
      updateHUD();
      nextTurn();
    }

    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); const p=getXY(e); placeAt(p.x,p.y); }, {passive:false});
    canvas.addEventListener('click', (e)=>{ const p=getXY(e); placeAt(p.x,p.y); });

    // Rendering
    function draw(){
      ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
      // subtle bg grid
      const g=28; ctx.beginPath();
      for(let x=0;x<canvas.clientWidth;x+=g){ctx.moveTo(x,0);ctx.lineTo(x,canvas.clientHeight);} 
      for(let y=0;y<canvas.clientHeight;y+=g){ctx.moveTo(0,y);ctx.lineTo(canvas.clientWidth,y);} 
      ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.stroke();

      // hexes
      for (let i=0;i<hexes.length;i++){
        const vids = hexVerts[i]; const col = hexes[i].col;
        ctx.beginPath();
        ctx.moveTo(vertices[vids[0]].x, vertices[vids[0]].y);
        for(let k=1;k<6;k++) ctx.lineTo(vertices[vids[k]].x, vertices[vids[k]].y);
        ctx.closePath();
        ctx.fillStyle = col.fill; ctx.fill();
        ctx.lineWidth = 2.2; ctx.strokeStyle = col.stroke; ctx.stroke();
      }

      // edges
      ctx.lineCap = 'round';
      for (const e of edges){
        const a = vertices[e.a], b = vertices[e.b];
        ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
        if (e.color===1)      ctx.strokeStyle = PLAYER_COLOR[P.BLACK];
        else if (e.color===2) ctx.strokeStyle = PLAYER_COLOR[P.WHITE];
        else if (e.color===3) ctx.strokeStyle = EDGE_GREY;
        else { ctx.strokeStyle = 'rgba(255,255,255,0.12)'; }
        ctx.lineWidth = e.color? 6 : 2.5;
        ctx.stroke();
      }

      // markers
      for (const v of vertices){
        if (v.owner===P.NONE) continue;
        ctx.beginPath(); ctx.arc(v.x, v.y, Math.max(6, 0.17*R), 0, Math.PI*2);
        ctx.fillStyle = v.owner===P.BLACK? PLAYER_COLOR[P.BLACK] : PLAYER_COLOR[P.WHITE];
        ctx.fill();
        ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.stroke();
      }
    }

    function relayout(){
      fitCanvas();
      buildBoard();
      updateHUD();
      draw();
    }

    // init & resize
    window.addEventListener('resize', relayout);
    relayout();
  </script>
</body>
</html>